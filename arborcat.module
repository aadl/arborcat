<?php

use Drupal\Core\Datetime\DrupalDateTime;

/**
 * Display help and module information
 * @return help text for section
 */
function arborcat_help($path, $arg)
{
    $output = '';

    switch ($path) {
    case "admin/help#arborcat":
      $output = '<p>' .  t("Catalog functions for Evergreen") . '</p>';
      break;
  }

    return $output;
}

function arborcat_theme($existing, $type, $theme, $path)
{
    return [
    'catalog' => [
      'variables' => [
        'catalog_slider' => null,
        'community_slider' => null,
        'podcast_slider' => null
      ]
    ],
    'catalog_record' => [
      'variables' => [
        'record' => null,
        'api_key' => null,
        'lists' => null,
        'reviews' => null,
        'review_form' => null,
        'ratings' => null
      ]
    ],
    'moderate_reviews' => [
      'variables' => [
        'reviews' => null,
        'pager' => null
      ]
    ],
    'pickup_request_form' => [
      'variables' => [
          'formhtml' => null,
      ]
    ],
    'patron_request_ready_locations_lookup_theme' => [
       'variables' => [
        'search_form' => null,
        'result_form' => null,
        'item' => null,
        'branches' =>null
      ]
    ],
   'patron_requests_ready_locations_theme' => [
      'variables' => [
        'search_form' => null,
        'location_urls' => null,
        'barcode' => null,
        'scheduled_pickups' => null
      ]
    ],
  ];
}

function arborcat_generate_api_key()
{
    // Use the UUID service to generate a Unique identifier
    $uuid_service = \Drupal::service('uuid');
    return $uuid_service->generate();
}

// set drupal messages for fees or expired card
function arborcat_patron_fines_expired($fines, $patron)
{
    $patron_clean = true;

    if ($fines->total > 25) {
        drupal_set_message("We're sorry, but your account balance is over $25. You won't be able to renew or request items.", 'error');
        $patron_clean = false;
    }
    if (strtotime($patron->expires) < time()) {
        drupal_set_message("We're sorry, but your card has expired! You can renew in person at any AADL Location.", 'error');
        $patron_clean = false;
    }

    return $patron_clean;
}

//check if a hold is eligible for a locker based on material type
  function arborcat_eligible_for_locker($hold)
  {
      if ($hold['material'] == "Art Print" || $hold['material'] == "Tools" || $hold['material'] == "Oversize") {
          return false;
      } else {
          return true;
      }
  }

  //check if there are lockers available to place holds into
  function arborcat_lockers_available($branch)
  {
      $mess = \Drupal::messenger();
      $available=false;
      if (stripos($branch, 'Malletts')!==false) {
          $locker_server = 'mcblockers';
      } elseif (stripos($branch, 'Pittsfield')!==false) {
          $locker_server = 'ptslockers';
      }
      if ($locker_server=='ptslockers') {
          $ch = curl_init();
          curl_setopt($ch, CURLOPT_URL, \Drupal::config('arborcat.settings')->get('pts_lockers'));
          curl_setopt($ch, CURLOPT_HEADER, 0);
          curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
          curl_setopt($ch, CURLOPT_USERPWD, \Drupal::config('arborcat.settings')->get('lockers_pass'));
          $result = curl_exec($ch);

          $simpleXML = simplexml_load_string($result);
          $i=1;
          $s = $simpleXML->doors->children();
          if ($s->assign1==0&$s->assign2==0&$s->assign3==0&$s->assign4==0) {
              $available=false;
          } elseif ($s->assign1!==0||$s->assign2!==0||$s->assign3!==0||$s->assign4!==0) {
              $available=true;
          }
      } elseif ($locker_server=='mcblockers') {
          $ch = curl_init();
          curl_setopt($ch, CURLOPT_URL, \Drupal::config('arborcat.settings')->get('mcb_lockers'));
          curl_setopt($ch, CURLOPT_HEADER, 0);
          curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
          curl_setopt($ch, CURLOPT_USERPWD, \Drupal::config('arborcat.settings')->get('lockers_pass'));
          $result = curl_exec($ch);
          if ($result != null) {
              preg_match_all('%name="web_patroninserted_door.*?value="([\d]+?)"%s', $result, $matches);
              if ($matches[1][0]>0) {
                  $available = true;
              }
          }
      }
      return $available;
  }

  /*
   * returns a list of request pickup locations.
   * If a branch location is passed in, that a filtered list of pickup locations is returned
   */
  function arborcat_pickup_locations($destLocation = null)
  {
      $db = \Drupal::database();
      $query = $db->select('arborcat_pickup_location', 'apl');
      $query->fields('apl', ['locationId', 'branchLocationId', 'timePeriod', 'timePeriodStart', 'timePeriodEnd', 'maxLockers', 'locationName', 'locationDescription']);
        
      // add in a condition if a location is supplied to filter on
      if (3 == strlen($destLocation)) {
          $query->condition('apl.branchLocationId', (int) $destLocation, '=');
      }
      $result = $query->execute();
      
      $pickupLocationRecords = $result->fetchAll();
      return $pickupLocationRecords;
  }

   /*
   * Checks the availability of a locker fo the specified date and timePeriod.
   * If a branch location is passed in, that a filtered list of pickup locations is returned
   */
  function arborcat_check_locker_availability($queryDate, $locationObject)
  {
      $availableLockers = 0;
      // Query current arborcat_patron_pickup_request records for the date and timePeriod to get inuse count
      // fields pickupDate & timeSlot
      $db = \Drupal::database();
      $pickup_point = $locationObject->locationId;

      $query = $db->select('arborcat_patron_pickup_request', 'appr')
        ->fields('appr', ['patronId'])
        ->condition('pickupDate', $queryDate)
        ->condition('pickupLocation', $pickup_point, '=')
        ->groupBy('patronId');
      $results = $query->execute()->fetchAll();

      $lockersInUse = count($results);
      $availableLockers = $locationObject->maxLockers - $lockersInUse;
      
      return ($availableLockers > 0);
  }

  function loadPatronEligibleHolds($patron_barcode, $requestLocation=null)
  {
      $guzzle = \Drupal::httpClient();
      $api_url = \Drupal::config('arborcat.settings')->get('api_url');
      $selfCheckApi_key = \Drupal::config('arborcat.settings')->get('selfcheck_key');
      $selfCheckApi_key .= '-' .  $patron_barcode;

      try {
        $patron_holds = json_decode($guzzle->get("$api_url/patron/$selfCheckApi_key/holds")->getBody()->getContents(), true);
      } catch (Exception $e) {
        $eligible_holds['error'] = 'Info not found';
        return $eligible_holds;
      }
      $eligible_holds = [];

      //start at 1 to avoid issue with eligible holds array not being zero-based
      $i=1;

      $mel_mappings = [
            113 => 102,
            114 => 103,
            115 => 104,
            116 => 105,
            117 => 106
      ];

      $db = \Drupal::database();
      if (count($patron_holds)) {
          foreach ($patron_holds as $hold) {
              if ($hold['status'] == 'Ready for Pickup') {
                  // check if there is a requestLocation to filter on. If not, set $includeLocationBoolean to true, otherwise perform check for location match
                  $includeLocationBoolean = ($requestLocation == null) ? true : ($hold['hold']['pickup_lib'] == $requestLocation);
                  if ($includeLocationBoolean || isset($mel_mappings[$hold['hold']['pickup_lib']])) {
                      // if pickup appt already set, don't display item
                      $pickup_req_exists = $db->query("SELECT * from arborcat_patron_pickup_request WHERE requestId = :hid", [':hid' => $hold['id']])->fetch();
                      if (isset($pickup_req_exists->id)) {
                          continue;
                      }
                      $shelf_expire = date('Y-m-d', strtotime($hold['hold']['shelf_expire_time']));
                      if (arborcat_eligible_for_locker($hold) && $shelf_expire >= date('Y-m-d')) {
                          $eligible_holds[$i] = [
                                'Title' => $hold['title'],
                                'Status' => $hold['status'],
                                'PickupLoc' => $hold['pickup'],
                                'pickup_lib' => $hold['hold']['pickup_lib'],
                                'holdId' => $hold['id'],
                                'usr' => $hold['hold']['usr']
                            ];
                          $i++;
                      }
                  }
              }
          }
      }
      return $eligible_holds;
  }

  function arborcat_get_scheduled_pickups($barcode) {
    $guzzle = \Drupal::httpClient();
    $api_url = \Drupal::config('arborcat.settings')->get('api_url');
    $selfCheckApi_key = \Drupal::config('arborcat.settings')->get('selfcheck_key');
    $selfCheckApi_key .= '-' .  $barcode;

    $scheduled_pickups = json_decode($guzzle->get("$api_url/patron/$selfCheckApi_key/scheduled-pickups")->getBody()->getContents(), true);

    return $scheduled_pickups;
  }
