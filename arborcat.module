<?php

use Drupal\Core\Datetime\DrupalDateTime;

/**
 * Display help and module information
 * @return help text for section
 */
function arborcat_help($path, $arg) {
  $output = '';

  switch ($path) {
  case "admin/help#arborcat":
    $output = '<p>' .  t("Catalog functions for Evergreen") . '</p>';

    break;
  }

  return $output;
}

function arborcat_theme($existing, $type, $theme, $path) {
  return [
    'catalog' => [
      'variables' => [
        'catalog_slider' => NULL,
        'community_slider' => NULL,
        'podcast_slider' => NULL
      ]
    ],
    'catalog_record' => [
      'variables' => [
        'record' => NULL,
        'api_key' => NULL,
        'lists' => NULL,
        'reviews' => NULL,
        'review_form' => NULL,
        'ratings' => NULL
      ]
    ],
    'moderate_reviews' => [
      'variables' => [
        'reviews' => NULL,
        'pager' => NULL
      ]
    ],
    'pickup_request_form' => [
      'variables' => [
          'formhtml' => NULL,
      ]
    ],
   'pickup_helper_theme' => [
      'variables' => [
        'search_form' => NULL,
        'location_urls' => NULL,
        'barcode' => NULL,
        'scheduled_pickups' => NULL
      ]
    ],
  ];
}

/**
 * @param $variables
 */
function arborcat_preprocess_page(&$variables) {
  // get the max locker item check  from ArborCat module settings
  $max_locker_items = \Drupal::config('arborcat.settings')->get('max_locker_items_check');
  $variables['#attached']['drupalSettings']['arborcat']['max_locker_items_check'] = $max_locker_items;
}

function arborcat_generate_api_key() {
  // Use the UUID service to generate a Unique identifier
  $uuid_service = \Drupal::service('uuid');

  return $uuid_service->generate();
}

// set drupal messages for fees or expired card
function arborcat_patron_fines_expired($fines, $patron) {
  $patron_clean = TRUE;
  $messenger = \Drupal::messenger();

  if ($fines->total > 25) {
    $messenger->addError("We're sorry, but your account balance is over $25. You won't be able to renew or request items.");
    $patron_clean = FALSE;
  }
  if (strtotime($patron->expires) < time()) {
    $message = \Drupal\Core\Render\Markup::create("We're sorry, but your card has expired! Details on how to <a href=\"https://aadl.org/node/569959\">renew online here</a>.");
    $messenger->addError($message);
    $patron_clean = FALSE;
  }

  return $patron_clean;
}

//check if a hold is eligible for a locker based on material type
function arborcat_eligible_for_locker($hold) {
  if ($hold['material'] == "Oversize") {
    return FALSE;
  } else {
    return TRUE;
  }
}

//check if there are lockers available to place holds into
function arborcat_lockers_available($branch) {
  $mess = \Drupal::messenger();
  $available=FALSE;
  if (stripos($branch, 'Malletts')!==FALSE) {
    $locker_server = 'mcblockers';
  } elseif (stripos($branch, 'Pittsfield')!==FALSE) {
    $locker_server = 'ptslockers';
  }
  if ($locker_server=='ptslockers') {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, \Drupal::config('arborcat.settings')->get('pts_lockers'));
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($ch, CURLOPT_USERPWD, \Drupal::config('arborcat.settings')->get('lockers_pass'));
    $result = curl_exec($ch);

    $simpleXML = simplexml_load_string($result);
    $i=1;
    $s = $simpleXML->doors->children();
    if ($s->assign1==0&$s->assign2==0&$s->assign3==0&$s->assign4==0) {
      $available = FALSE;
    } elseif ($s->assign1!==0||$s->assign2!==0||$s->assign3!==0||$s->assign4!==0) {
      $available = TRUE;
    }
  } elseif ($locker_server=='mcblockers') {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, \Drupal::config('arborcat.settings')->get('mcb_lockers'));
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($ch, CURLOPT_USERPWD, \Drupal::config('arborcat.settings')->get('lockers_pass'));
    $result = curl_exec($ch);
    if ($result != NULL) {
      preg_match_all('%name="web_patroninserted_door.*?value="([\d]+?)"%s', $result, $matches);
      if ($matches[1][0]>0) {
        $available = TRUE;
      }
    }
  }

  return $available;
}

/*
  * returns a list of request pickup locations.
  * If a branch location is passed in, that a filtered list of pickup locations is returned
  */
function arborcat_pickup_locations($destLocation = NULL, $lookupName = NULL, $frontBack = NULL, $lobbyOnly = NULL) {
  $db = \Drupal::database();
  $query = $db->select('arborcat_pickup_location', 'apl')
    ->fields('apl', ['locationId', 'branchLocationId', 'timePeriod', 'timePeriodStart', 'timePeriodEnd', 'maxLockers', 'locationName', 'locationDescription'])
    ->condition('active', 1, "=");

  // if lookupName supplied, get lib locations and lookup the branch number.
  // Then set the parameter $destlocation to the branch number. If set, the location filter will be applied
  if (strlen($lookupName) > 0) {
    $guzzle = \Drupal::httpClient();
    $api_url = \Drupal::config('arborcat.settings')->get('api_url');
    $locations = json_decode($guzzle->get("$api_url/locations")->getBody()->getContents());
    foreach ($locations as $key => $value) {
      if (strpos($value, $lookupName) !== FALSE) {
        $destLocation = $key;

        break;
      }
    }
  }
  // add in a condition if a location is supplied to filter on
  if (3 == strlen($destLocation)) {
    $query->condition('branchLocationId', (int) $destLocation, '=');
  }
  // add in a condition if a lobbyOnly is supplied to filter on
  if (NULL != $lobbyOnly) {
    $query->condition('maxLockers', 0, '=');
  }
  // add in a condition for 'Front' versus 'Back' in the location Name
  if (NULL != $frontBack) {
    $query->condition('locationName', "%" . $db->escapeLike($frontBack) . "%", 'like');
  }
  $result = $query->execute();
  $pickupLocationRecords = $result->fetchAll();

  return $pickupLocationRecords;
}

/*
  * returns an array of active locker pickup locations.
  */
function arborcat_locker_pickup_locations() {
  $locations = [];
  $db = \Drupal::database();
  $query = $db->select('arborcat_pickup_location', 'apl')
      ->fields('apl', ['locationId'])
      ->condition('maxLockers', 0, '>')
      ->condition('active', 1, '=')
      ->execute();
  $locations = array_values($query->fetchCol());

  return $locations;
}

  /*
  * Checks the availability of a locker fo the specified date and timePeriod.
  * If a branch location is passed in, that a filtered list of pickup locations is returned
  */
function arborcat_check_locker_availability($queryDate, $locationObject, $patronId) {
  $availableLockers = 0;
  // Query current arborcat_patron_pickup_request records for the date and timePeriod to get inuse count
  // fields pickupDate & timeSlot
  $db = \Drupal::database();
  $pickup_point = $locationObject->locationId;

  $query = $db->select('arborcat_patron_pickup_request', 'appr')
    ->fields('appr', ['patronId'])
    ->condition('pickupDate', $queryDate)
    ->condition('pickupLocation', $pickup_point, '=')
    ->groupBy('patronId');
  $results = $query->execute()->fetchCol();

  $lockersInUse = count($results);
  $availableLockers = $locationObject->maxLockers - $lockersInUse;
  $returnval = FALSE;
  // check whether this patron already has a pickup appointment already scheduled for this locker at this time. OR whether there are available lockers at this time
  if (in_array($patronId, $results) || $availableLockers > 0) {
    $returnval = TRUE;
  }

  return ($returnval);
}

function arborcat_load_patron_eligible_holds($patron_barcode, $requestLocation=NULL) {
  $guzzle = \Drupal::httpClient();
  $api_url = \Drupal::config('arborcat.settings')->get('api_url');
  $selfCheckApi_key = \Drupal::config('arborcat.settings')->get('selfcheck_key');
  $selfCheckApi_key .= '-' .  $patron_barcode;

  try {
    $patron_holds = json_decode($guzzle->get("$api_url/patron/$selfCheckApi_key/holds")->getBody()->getContents(), TRUE);

    // For debugging LWK
    // $jsonData = file_get_contents('10005279_21621034452183_holds.txt');
    // $patron_holds = json_decode($jsonData, TRUE);
  } catch (Exception $e) {
    $eligible_holds['error'] = 'Info not found';

    return $eligible_holds;
  }
  $eligible_holds = [];
  //start at 1 to avoid issue with eligible holds array not being zero-based
  $i=1;

  $mel_mappings = [
        113 => 102,
        114 => 103,
        115 => 104,
        116 => 105,
        117 => 106
  ];

  $db = \Drupal::database();
  if (count($patron_holds)) {
    foreach ($patron_holds as $hold) {
      if ($hold['status'] == 'Ready for Pickup') {
        // check if there is a requestLocation to filter on. If not, set $includeLocationBoolean to TRUE, otherwise perform check for location match
        $includeLocationBoolean = ($requestLocation == NULL) ? TRUE : ($hold['hold']['pickup_lib'] == $requestLocation);
        if ($includeLocationBoolean || isset($mel_mappings[$hold['hold']['pickup_lib']])) {
          // if pickup appt already set, don't display item
          $pickup_req_exists = $db->query("SELECT * from arborcat_patron_pickup_request WHERE requestId = :hid", [':hid' => $hold['id']])->fetch();
          if (isset($pickup_req_exists->id)) {
            continue;
          }
          $shelf_expire = date('Y-m-d', strtotime($hold['hold']['shelf_expire_time']));
          if (arborcat_eligible_for_locker($hold) && $shelf_expire >= date('Y-m-d')) {
            $eligible_holds[$i] = [
                            'Title' => $hold['title'],
                            'Status' => $hold['status'],
                            'PickupLoc' => $hold['pickup'],
                            'pickup_lib' => $hold['hold']['pickup_lib'],
                            'holdId' => $hold['id'],
                            'usr' => $hold['hold']['usr'],
                            'artPrintTool' => ($hold['material'] == "Art Print" || $hold['material'] == "Tools") ? TRUE : FALSE
                        ];
            $i++;
          }
        }
      }
    }
  }

  return $eligible_holds;
}

function arborcat_get_scheduled_pickups($barcode) {
  $guzzle = \Drupal::httpClient();
  $api_url = \Drupal::config('arborcat.settings')->get('api_url');
  $selfCheckApi_key = \Drupal::config('arborcat.settings')->get('selfcheck_key');
  $selfCheckApi_key .= '-' .  $barcode;

  $scheduled_pickups = json_decode($guzzle->get("$api_url/patron/$selfCheckApi_key/scheduled-pickups?range=7")->getBody()->getContents(), TRUE);

  return $scheduled_pickups;
}

function arborcat_create_pickup_request_record($pickup_request_type, $customId, $patronId, $branch, $timeSlot, $pickupLocation, $pickupDate, $contactEmail, $contactSMS, $contactPhone, $lockerCode) {
  // create arborcat_patron_pickup_request records for each of the selected holds
  $db = \Drupal::database();

  // First check if the record already exists for this customId
  $results = [];
  try {
    $query = $db->select('arborcat_patron_pickup_request', 'appr')
      ->fields('appr', ['id'])
      ->condition('requestId', $customId, '=');
    $results = $query->execute()->fetchCol();
  } catch (Exception $e) {
    return -1;
  }
  // If a record exists containing the $customId, just return the id of the record, otherwise insert a new record with the customId and return the $id of the new record
  if (count($results) > 0) {
    return $results[0];
  } else {
    $txn = $db->startTransaction();
    try {
      $dbaction = $db->insert('arborcat_patron_pickup_request')->fields([
        'requestType'   => $pickup_request_type,
        'requestId'     => $customId,
        'patronId'      => $patronId,
        'branch'        => (int) $branch,
        'timeSlot'      => $timeSlot,
        'pickupLocation' => $pickupLocation,
        'pickupDate'    => $pickupDate,
        'contactEmail'  => $contactEmail,
        'contactSMS'    => $contactSMS,
        'contactPhone'  => $contactPhone,
        'created'       => time(),
        'locker_code'   => $lockerCode
      ]);
      $id = $dbaction->execute();

      return $id;
    } catch (Exception $e) {
      $txn->rollBack();

      return -1;
    }
  }
}

function barcodeFromPatronId($patronId) {
  $api_key = \Drupal::config('arborcat.settings')->get('api_key');
  $api_url = \Drupal::config('arborcat.settings')->get('api_url');
  $guzzle = \Drupal::httpClient();
  $requestURL = "$api_url/patron?apikey=$api_key&pnum=$patronId";
  $json = json_decode($guzzle->get($requestURL)->getBody()->getContents());
  if ($json) {
    $barcode =  $json->evg_user->card->barcode;

    return $barcode;
  } else {
    return "";
  }
}

function patronIdFromBarcode($barcode) {
  $api_key = \Drupal::config('arborcat.settings')->get('api_key');
  $api_url = \Drupal::config('arborcat.settings')->get('api_url');
  $guzzle = \Drupal::httpClient();
  $requestURL = "$api_url/patron?apikey=$api_key&barcode=$barcode";
  $json = json_decode($guzzle->get($requestURL)->getBody()->getContents());
  if ($json) {
    $patronId =  $json->pid;

    return $patronId;
  } else {
    return "";
  }
}
  
function arborcat_custom_pickup_request($pickup_request_type, $customPickupRequestId) {
  $resultMessage = '';
  if ($pickup_request_type == 'PRINT_JOB' || $pickup_request_type == 'GRAB_BAG') {
    // Extract fields from the printJob request form
    $db = \Drupal::database();
    $query = $db->select('webform_submission_data', 'wsd');
    $query->fields('wsd', ['name', 'value']);
    $query->condition('sid', $customPickupRequestId, '=');
    $rawNameValueResults= $query->execute()->fetchAll();

    // process the raw results and create an associative array of the results.
    // NOTE notification_options can have multiple entries and this is handled by creating a regular array of the different result values
    $assocResults = [];
    foreach ($rawNameValueResults as $entry) {
      $keyname = $entry->name;
      if ("notification_options" == $keyname) {
        if (!array_key_exists($keyname, $assocResults)) {
          $assocResults[$keyname] = [];
        }
        array_push($assocResults[$keyname], $entry->value);
      } else {
        $assocResults[$keyname] = $entry->value;
      }
    }

    if (count($assocResults) > 0) {
      $barcode = $assocResults['barcode'];
      $patronId = (strlen($barcode) == 14) ? patronIdFromBarcode($barcode) : NULL;
      $branchNameArray = explode(" ", $assocResults['delivery_method']);
      if ($branchNameArray[0] == 'Mail') {  // Mail to Patron option - no pickup request should be created
        $resultMessage = 'SUCCESS';
      }
      else {
        $frontBack = ($branchNameArray[1] == 'Back' || $branchNameArray[1] == 'Front') ? $branchNameArray[1] : NULL;
        $pickupLocations = arborcat_pickup_locations(NULL, $branchNameArray[0], $frontBack, TRUE);
        $branch = $pickupLocations[0]->branchLocationId;
        $pickupLocation = $pickupLocations[0]->locationId;

        $timeslot = 0;
        $pickupDate = $assocResults['pickup_date'];
        $patronPhone = $assocResults['patron_phone'];
        $patronEmail = $assocResults['patron_email'];
        $notification_options = $assocResults['notification_options'];
        // create new arborcat_pickup_request_record (if one does not already exist)
        $result = arborcat_create_pickup_request_record(
          $pickup_request_type,
          $customPickupRequestId,
          $patronId,
          $branch,
          $timeslot,
          $pickupLocation,
          $pickupDate,
          $patronEmail,
          (in_array('email', array_map('strtolower', $notification_options))) ? $patronEmail : NULL,
          (in_array('text', array_map("strtolower", $notification_options))) ? $patronPhone : NULL,
          (in_array('phone call', array_map("strtolower", $notification_options))) ? $patronPhone : NULL,
          $patronPhone ?? NULL
        );
                                      
        if ($result > 0) {
          $resultMessage = 'SUCCESS';
        } else {
          $resultMessage = 'Failed to create Pickup Request Record';
        }
      }
    }
  } elseif ($pickup_request_type == 'SG_ORDER') {
  }

  return $resultMessage;
}

 function arborcat_load_exclusion_data($location, $startDateYmd, $endDateYmd) {
   dblog("\n\n", 'ENTERED arborcat_load_exclusion_data, location = ', $location, '|', $startDateYmd, '|',  $endDateYmd);
  // Load exclusion dates for date range defined in the two params from the table: arborcat_pickup_location_exclusion
  // For all branches (locationId=9999) 
  $db = \Drupal::database();
  $query = $db->select('arborcat_pickup_location_exclusion', 'aple');
  $query->fields('aple', ['locationId', 'dateStart', 'dateEnd','display_reason']);
  $query->condition('dateStart', $startDateYmd, '>=');
  // dateEnd could be null or a real date - need to form query for one OR the other
  $orGroup = $query->orConditionGroup()
    ->condition('dateEnd', $endDateYmd, '<=')
    ->condition('dateEnd', null, '=');
  $query->condition($orGroup);

  // array initialized with "library wide" location Id - 9999
  $queryLocationIds = array(9999);

  if ($location < 1000) { // must be a branch location so we need to get all the pickup location ids for that branch
    $branchLocationIds = arborcat_get_pickup_locations($location);
    array_push($queryLocationIds, ...$branchLocationIds);
  }

  // always push the location passed in because the exclusion record may contain
  array_push($queryLocationIds, $location);
  
  dblog('arborcat_load_exclusion_data: BEFORE ADDING IN condition, $queryLocationIds = ', $queryLocationIds);
  $query->condition('locationId', $queryLocationIds, 'IN');
 
  $result = $query->execute();
  $exclusionData = $result->fetchAll();
  dblog('arborcat_load_exclusion_data: RETURNING exclusionData = ', $exclusionData);

  return $exclusionData;
}

function arborcat_get_pickup_locations($branchLocationId) {
  $db = \Drupal::database();
  $query = $db->select('arborcat_pickup_location', 'apl');
  $query->fields('apl', ['locationId']);
  $query->condition('branchLocationId', $branchLocationId, '=');
  $result = $query->execute();
  $locationIds = $result->fetchCol();

  dblog('arborcat_get_pickup_locations: RETURNING pickup locationIds = ', json_encode($locationIds));
  return $locationIds;
}

function dblog(...$thingsToLog) {
  $lineToLog = '';
  foreach ($thingsToLog as $item) {
    //$lineToLog = $lineToLog . ' ' . print_r($item, true);
    $item2 = $item;
    if (is_array($item)) {
      $item2 = ' ARRAY: ' . json_encode($item);
    } elseif (is_object($item)) {
      $item2 = 'OBJECT: ' . json_encode($item);
    }
    $lineToLog .= ' ' . $item2;
  }
  // prepend date/time onto log line
  $nowDateTime = new DrupalDateTime();
  $dateTimeString = (string) $nowDateTime->format('Y-m-d H:i:s');
  $completeLine = '[' . $dateTimeString . '] ' . $lineToLog . "\n";
  error_log($completeLine, 3, "LWKLWK.log");
}
