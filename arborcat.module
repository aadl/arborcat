<?php

use Drupal\Core\Datetime\DrupalDateTime;

/**
 * Display help and module information
 * @return help text for section
 */
function arborcat_help($path, $arg) {
  $output = '';

  switch ($path) {
  case "admin/help#arborcat":
    $output = '<p>' .  t("Catalog functions for Evergreen") . '</p>';
    break;
  }

  return $output;
}

function arborcat_theme($existing, $type, $theme, $path) {
  return [
    'catalog' => [
      'variables' => [
        'catalog_slider' => NULL,
        'community_slider' => NULL,
        'podcast_slider' => NULL
      ]
    ],
    'catalog_record' => [
      'variables' => [
        'record' => NULL,
        'api_key' => NULL,
        'lists' => NULL,
        'reviews' => NULL,
        'review_form' => NULL,
        'ratings' => NULL
      ]
    ],
    'moderate_reviews' => [
      'variables' => [
        'reviews' => NULL,
        'pager' => NULL
      ]
    ],
    'pickup_request_form' => [
      'variables' => [
          'formhtml' => NULL,
      ]
    ],
    'patron_request_ready_locations_lookup_theme' => [
       'variables' => [
        'search_form' => NULL,
        'result_form' => NULL,
        'item' => NULL,
        'branches' =>NULL
      ]
    ],
   'patron_requests_ready_locations_theme' => [
      'variables' => [
        'search_form' => NULL,
        'location_urls' => NULL,
        'barcode' => NULL,
        'scheduled_pickups' => NULL
      ]
    ],
  ];
}

/**
 * @param $variables
 */
function arborcat_preprocess_page(&$variables)
{
  // get the max locker item check  from ArborCat module settings
  $max_locker_items = \Drupal::config('arborcat.settings')->get('max_locker_items_check');
  $variables['#attached']['drupalSettings']['arborcat']['max_locker_items_check'] = $max_locker_items;
 // $variables['#attached']['drupalSettings']['arborcat']['pickup_date_options'] = arborcat_calculateLobbyPickupDates($requestLocation);
//  $variables['#attached']['drupalSettings']['arborcat']['pickup_locations'] = arborcat_pickup_locations($requestLocation);
}

function arborcat_generate_api_key() {
  // Use the UUID service to generate a Unique identifier
  $uuid_service = \Drupal::service('uuid');
  return $uuid_service->generate();
}

// set drupal messages for fees or expired card
function arborcat_patron_fines_expired($fines, $patron) {
  $patron_clean = TRUE;

  if ($fines->total > 25) {
      drupal_set_message("We're sorry, but your account balance is over $25. You won't be able to renew or request items.", 'error');
      $patron_clean = FALSE;
  }
  if (strtotime($patron->expires) < time()) {
      drupal_set_message("We're sorry, but your card has expired! You can renew in person at any AADL Location.", 'error');
      $patron_clean = FALSE;
  }

  return $patron_clean;
}

//check if a hold is eligible for a locker based on material type
  function arborcat_eligible_for_locker($hold) {
    if ($hold['material'] == "Art Print" || $hold['material'] == "Tools" || $hold['material'] == "Oversize") {
        return FALSE;
    } else {
        return TRUE;
    }
  }

  //check if there are lockers available to place holds into
  function arborcat_lockers_available($branch) {
    $mess = \Drupal::messenger();
    $available=FALSE;
    if (stripos($branch, 'Malletts')!==FALSE) {
        $locker_server = 'mcblockers';
    } elseif (stripos($branch, 'Pittsfield')!==FALSE) {
        $locker_server = 'ptslockers';
    }
    if ($locker_server=='ptslockers') {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, \Drupal::config('arborcat.settings')->get('pts_lockers'));
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_USERPWD, \Drupal::config('arborcat.settings')->get('lockers_pass'));
        $result = curl_exec($ch);

        $simpleXML = simplexml_load_string($result);
        $i=1;
        $s = $simpleXML->doors->children();
        if ($s->assign1==0&$s->assign2==0&$s->assign3==0&$s->assign4==0) {
            $available = FALSE;
        } elseif ($s->assign1!==0||$s->assign2!==0||$s->assign3!==0||$s->assign4!==0) {
            $available = TRUE;
        }
    } elseif ($locker_server=='mcblockers') {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, \Drupal::config('arborcat.settings')->get('mcb_lockers'));
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($ch, CURLOPT_USERPWD, \Drupal::config('arborcat.settings')->get('lockers_pass'));
        $result = curl_exec($ch);
        if ($result != NULL) {
            preg_match_all('%name="web_patroninserted_door.*?value="([\d]+?)"%s', $result, $matches);
            if ($matches[1][0]>0) {
                $available = TRUE;
            }
        }
    }
    return $available;
  }

  /*
   * returns a list of request pickup locations.
   * If a branch location is passed in, that a filtered list of pickup locations is returned
   */
  function arborcat_pickup_locations($destLocation = NULL){
    $db = \Drupal::database();
    $query = $db->select('arborcat_pickup_location', 'apl')
      ->fields('apl', ['locationId', 'branchLocationId', 'timePeriod', 'timePeriodStart', 'timePeriodEnd', 'maxLockers', 'locationName', 'locationDescription'])
      ->condition('active', 1, "=");

    // add in a condition if a location is supplied to filter on
    if (3 == strlen($destLocation)) {
        $query->condition('apl.branchLocationId', (int) $destLocation, '=');
    }
    $result = $query->execute();
    
    $pickupLocationRecords = $result->fetchAll();
    return $pickupLocationRecords;
  }

  /*
   * returns an array of active locker pickup locations.
   */
  function arborcat_locker_pickup_locations() {
    $locations = [];
    $db = \Drupal::database();
    $query = $db->select('arborcat_pickup_location', 'apl')
        ->fields('apl', ['locationId'])
        ->condition('maxLockers', 0, '>')
        ->condition('active', 1, '=')
        ->execute();
    $locations = array_values($query->fetchCol());
    return $locations;
  }


   /*
   * Checks the availability of a locker fo the specified date and timePeriod.
   * If a branch location is passed in, that a filtered list of pickup locations is returned
   */
  function arborcat_check_locker_availability($queryDate, $locationObject) {
    $availableLockers = 0;
    // Query current arborcat_patron_pickup_request records for the date and timePeriod to get inuse count
    // fields pickupDate & timeSlot
    $db = \Drupal::database();
    $pickup_point = $locationObject->locationId;

    $query = $db->select('arborcat_patron_pickup_request', 'appr')
      ->fields('appr', ['patronId'])
      ->condition('pickupDate', $queryDate)
      ->condition('pickupLocation', $pickup_point, '=')
      ->groupBy('patronId');
    $results = $query->execute()->fetchAll();

    $lockersInUse = count($results);
    $availableLockers = $locationObject->maxLockers - $lockersInUse;
    
    return ($availableLockers > 0);
  }

  function arborcat_load_patron_eligible_holds($patron_barcode, $requestLocation=NULL) {
    $guzzle = \Drupal::httpClient();
    $api_url = \Drupal::config('arborcat.settings')->get('api_url');
    $selfCheckApi_key = \Drupal::config('arborcat.settings')->get('selfcheck_key');
    $selfCheckApi_key .= '-' .  $patron_barcode;

    try {
      $patron_holds = json_decode($guzzle->get("$api_url/patron/$selfCheckApi_key/holds")->getBody()->getContents(), TRUE);

      // For debugging LWK  
      // $jsonData = file_get_contents('10005279_21621034452183_holds.txt');
      // $patron_holds = json_decode($jsonData, TRUE);

    } catch (Exception $e) {
      $eligible_holds['error'] = 'Info not found';
      return $eligible_holds;
    }
    $eligible_holds = [];
    //start at 1 to avoid issue with eligible holds array not being zero-based
    $i=1;

    $mel_mappings = [
          113 => 102,
          114 => 103,
          115 => 104,
          116 => 105,
          117 => 106
    ];

    $db = \Drupal::database();
    if (count($patron_holds)) {
        foreach ($patron_holds as $hold) {
            if ($hold['status'] == 'Ready for Pickup') {
                // check if there is a requestLocation to filter on. If not, set $includeLocationBoolean to TRUE, otherwise perform check for location match
                $includeLocationBoolean = ($requestLocation == NULL) ? TRUE : ($hold['hold']['pickup_lib'] == $requestLocation);
                if ($includeLocationBoolean || isset($mel_mappings[$hold['hold']['pickup_lib']])) {
                    // if pickup appt already set, don't display item
                    $pickup_req_exists = $db->query("SELECT * from arborcat_patron_pickup_request WHERE requestId = :hid", [':hid' => $hold['id']])->fetch();
                    if (isset($pickup_req_exists->id)) {
                        continue;
                    }
                    $shelf_expire = date('Y-m-d', strtotime($hold['hold']['shelf_expire_time']));
                    if (arborcat_eligible_for_locker($hold) && $shelf_expire >= date('Y-m-d')) {
                        $eligible_holds[$i] = [
                              'Title' => $hold['title'],
                              'Status' => $hold['status'],
                              'PickupLoc' => $hold['pickup'],
                              'pickup_lib' => $hold['hold']['pickup_lib'],
                              'holdId' => $hold['id'],
                              'usr' => $hold['hold']['usr']
                          ];
                        $i++;
                    }
                }
            }
        }
    }
    return $eligible_holds;
  }

function loadPatronEligibleHolds($patron_barcode, $requestLocation=null)
{
    $guzzle = \Drupal::httpClient();
    $api_url = \Drupal::config('arborcat.settings')->get('api_url');
    $selfCheckApi_key = \Drupal::config('arborcat.settings')->get('selfcheck_key');
    $selfCheckApi_key .= '-' .  $patron_barcode;

    try {
      $patron_holds = json_decode($guzzle->get("$api_url/patron/$selfCheckApi_key/holds")->getBody()->getContents(), true);
    } catch (Exception $e) {
      $eligible_holds['error'] = 'Info not found';
      return $eligible_holds;
    }
    $eligible_holds = [];

    //start at 1 to avoid issue with eligible holds array not being zero-based
    $i=1;

    $mel_mappings = [
          113 => 102,
          114 => 103,
          115 => 104,
          116 => 105,
          117 => 106
    ];

    $db = \Drupal::database();
    if (count($patron_holds)) {
        foreach ($patron_holds as $hold) {
            if ($hold['status'] == 'Ready for Pickup') {
                // check if there is a requestLocation to filter on. If not, set $includeLocationBoolean to true, otherwise perform check for location match
                $includeLocationBoolean = ($requestLocation == null) ? true : ($hold['hold']['pickup_lib'] == $requestLocation);
                if ($includeLocationBoolean || isset($mel_mappings[$hold['hold']['pickup_lib']])) {
                    // if pickup appt already set, don't display item
                    $pickup_req_exists = $db->query("SELECT * from arborcat_patron_pickup_request WHERE requestId = :hid", [':hid' => $hold['id']])->fetch();
                    if (isset($pickup_req_exists->id)) {
                        continue;
                    }
                    $shelf_expire = date('Y-m-d', strtotime($hold['hold']['shelf_expire_time']));
                    if (arborcat_eligible_for_locker($hold) && $shelf_expire >= date('Y-m-d')) {
                        $eligible_holds[$i] = [
                              'Title' => $hold['title'],
                              'Status' => $hold['status'],
                              'PickupLoc' => $hold['pickup'],
                              'pickup_lib' => $hold['hold']['pickup_lib'],
                              'holdId' => $hold['id'],
                              'usr' => $hold['hold']['usr']
                          ];
                        $i++;
                    }
                }
            }
        }
    }
    return $eligible_holds;
}

function arborcat_get_scheduled_pickups($barcode) {
  $guzzle = \Drupal::httpClient();
  $api_url = \Drupal::config('arborcat.settings')->get('api_url');
  $selfCheckApi_key = \Drupal::config('arborcat.settings')->get('selfcheck_key');
  $selfCheckApi_key .= '-' .  $barcode;

  $scheduled_pickups = json_decode($guzzle->get("$api_url/patron/$selfCheckApi_key/scheduled-pickups")->getBody()->getContents(), true);

  return $scheduled_pickups;
}

// return the active pickup location Ids for the branch location specified in the hold requests
function arborcat_pickupLocations($holdPickupLocation) {
  $db = \Drupal::database();
  $query = $db->select('arborcat_pickup_location', 'apl')
              ->fields('apl', ['locationId'])
              ->condition('branchLocationId', $holdPickupLocation, '=')
              ->condition('active', 1, '=')
              ->execute();
  $returneditems = $query->fetchAll();
  $pickupLocationIds = [];
  foreach($returneditems as $item) {
    array_push($pickupLocationIds, $item->locationId);
  }
  return $pickupLocationIds;
}

//check if a hold is eligible for a locker based on material type
function arborcat_calculateLobbyPickupDates($holdPickupLocation) {
  $arrayOfDates = [];
  // get the current date
  $theDate = new DateTime('today');
  // add 1 day to the current date
  $startingDayOffset = 1; // Load these from ArborCat Settings?
  $numPickupDays = 7;     // Load these from ArborCat Settings?
  $incrementorString = '+$startingDayOffset day';
  $theDate->modify('+1 day');
  $tomorrow = $theDate->format('Y-m-d');
  $endingPickupDate = new DateTime($theDate->format("Y-m-d H:i:s"));
  $endingPickupDate->modify('+7 day');
  $tomorrowPlusSevenDays = $endingPickupDate->format('Y-m-d');
  // now loop for x days and create a date string for each day, preceded with the day name
  // create a human friendly version - 'formattedDate' for display purposes in the UI
  // and a basic verson 'date' for use in date db queries

  // Next 7 days exclusion date/locations
  $db = \Drupal::database();
  $query = $db->select('arborcat_pickup_location_exclusion', 'aple')
              ->fields('aple', ['locationId', 'exclusionDate',])
              ->condition('exclusionDate', $tomorrow, '>=')
              ->condition('exclusionDate', $tomorrowPlusSevenDays, '<=')
              ->execute();
  $location_date_excludes = $query->fetchAll();
  $activePickupLocations = arborcat_pickupLocations($holdPickupLocation);

  for ($x=0; $x < $numPickupDays; $x++) {
    $theDate_mdY = $theDate->format('M. j');
    $day_of_week = intval($theDate->format('w'));
    $dayOfWeek = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat',][$day_of_week];
    $datestring = $dayOfWeek . ', ' . $theDate_mdY;
    $datestr_Ymd = $theDate->format('Y-m-d');
    // Loop through exclusions looking for dates matching and that the exclusion pickupLocation is in the list of locations for the 
    // hold request location
    $exclusionLocations = [];
    foreach($location_date_excludes as $oneLocDateExclude) {
      if ($oneLocDateExclude->exclusionDate == $datestr_Ymd && in_array($oneLocDateExclude->locationId, $activePickupLocations)) {
        array_push($exclusionLocations, $oneLocDateExclude->locationId);
      }
    }
    // The following line is if the exclusion locations are to be passedto thefront-endJS
    //$dateLineData = array("date" => $datestr_Ymd, "formattedDate" => $datestring, "exclusions" => $exclusionLocations);
    $dateLineData = array("date" => $datestr_Ymd, "formattedDate" => $datestring);
    // only add the date if there are no exclusions for this location on this date
    if (count($exclusionLocations) == 0) {
      $arrayOfDates[$datestr_Ymd] = $dateLineData;
    }
    $theDate->modify('+1 day');
  }
  return $arrayOfDates;
}

function dblog(...$thingsToLog)
{
  $lineToLog = '';
  foreach ($thingsToLog as $item) {
    $item2 = $item;
    if (is_array($item)) {
      $item2 = ' ARRAY: ' . json_encode($item);
    }
    else if (is_object($item)) {
      $item2 = 'OBJECT: ' . json_encode($item);
    }
    $lineToLog .= ' ' . $item2;
  }
  // prepend date/time onto log line
  $nowDateTime = new DrupalDateTime();
  $dateTimeString = (string) $nowDateTime->format('Y-m-d H:i:s');
  $completeLine = '[' . $dateTimeString . '] ' . $lineToLog . "\n";
  error_log($completeLine, 3, "LWKLWK.log");
}
